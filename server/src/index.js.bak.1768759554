require("dotenv").config();
const express = require("express");
const dbMod = require("./db");
const initDb = dbMod.initDb || dbMod.init;
const cors = require("cors");
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");
const { z } = require("zod");
const { init, run, get, all } = require("./db");
const { requireAuth } = require("./auth");

const app = express();

((initDb || (async()=>{}))()).catch((e)=>{ console.error("DB init failed:", e); 
(async () => {
  const add = async (sql) => { try { await run(sql); } catch(e) {} };
  await add("ALTER TABLE users ADD COLUMN full_name TEXT");
  await add("ALTER TABLE users ADD COLUMN payment_number TEXT");
  await add("ALTER TABLE users ADD COLUMN bonus_ksh REAL DEFAULT 0");
  await add("ALTER TABLE users ADD COLUMN delete_requested_at TEXT");
  await add("ALTER TABLE users ADD COLUMN delete_effective_at TEXT");
})();
process.exit(1); });
app.use(cors());
app.use(express.json());
require("./migrate")().catch(console.error);
app.use("/api/account", require("./account"));

const PORT = process.env.PORT || 5175;
const JWT_SECRET = process.env.JWT_SECRET || "dev_secret_change_me";

function makeReferralCode(username) {
  const base = username.replace(/[^a-z0-9]/gi, "").slice(0, 6).toUpperCase() || "USER";
  const rand = Math.floor(1000 + Math.random() * 9000);
  return base + rand;
}

app.get("/api/health", (req, res) => res.json({ ok: true }));

const RegisterSchema = z.object({
  username: z.string().min(3),
  email: z.string().email(),
  password: z.string().min(6),
  referralCode: z.string().optional().default("")
});

app.post("/api/auth/register", async (req, res) => {
  try {
    const data = RegisterSchema.parse(req.body);

    const existsEmail = await get("SELECT id FROM users WHERE email = ?", [data.email]);
    if (existsEmail) return res.status(400).json({ error: "Email already registered" });

    const existsUser = await get("SELECT id FROM users WHERE username = ?", [data.username]);
    if (existsUser) return res.status(400).json({ error: "Username already taken" });

    let referredById = null;
    if (data.referralCode && data.referralCode.trim()) {
      const ref = await get("SELECT id FROM users WHERE referral_code = ?", [data.referralCode.trim()]);
      if (!ref) return res.status(400).json({ error: "Invalid referral code" });
      referredById = ref.id;
    }

    const password_hash = await bcrypt.hash(data.password, 10);

    // ensure unique referral code
    let referral_code = makeReferralCode(data.username);
    for (let i = 0; i < 5; i++) {
      const existsCode = await get("SELECT id FROM users WHERE referral_code = ?", [referral_code]);
      if (!existsCode) break;
      referral_code = makeReferralCode(data.username);
    }

    const userInsert = await run(
      "INSERT INTO users (username, email, password_hash, referral_code, referred_by, balance_ksh) VALUES (?, ?, ?, ?, ?, 0)",
      [data.username, data.email, password_hash, referral_code, referredById]
    );

    // referral bonus: give referrer 100 KSH
    if (referredById) {
      await run("UPDATE users SET bonus_ksh = COALESCE(bonus_ksh,0) + 100 WHERE id = ?", [referredById]);
    }

    const token = jwt.sign({ id: userInsert.lastID }, JWT_SECRET, { expiresIn: "7d" });
    res.json({ token });
  } catch (e) {
    res.status(400).json({ error: e.message || "Bad request" });
  }
});

const LoginSchema = z.object({
  email: z.string().email(),
  password: z.string().min(1)
});

app.post("/api/auth/login", async (req, res) => {
  try {
    const data = LoginSchema.parse(req.body);
    const user = await get("SELECT id, password_hash FROM users WHERE email = ?", [data.email]);
    if (!user) return res.status(400).json({ error: "Invalid credentials" });

    const ok = await bcrypt.compare(data.password, user.password_hash);
    if (!ok) return res.status(400).json({ error: "Invalid credentials" });

    const token = jwt.sign({ id: user.id }, JWT_SECRET, { expiresIn: "7d" });
    res.json({ token });
  } catch (e) {
    res.status(400).json({ error: e.message || "Bad request" });
  }
});

app.get("/api/me", requireAuth, async (req, res) => {
  const u = await get(
    "SELECT id, username, email, phone, referral_code, balance_ksh, COALESCE(bonus_ksh,0) AS bonus_ksh, COALESCE(full_name,"") AS full_name, COALESCE(payment_number,"") AS payment_number, created_at, delete_requested_at, delete_effective_at FROM users WHERE id = ?",
    [req.user.id]
  );
  

app.put("/api/me", require("./auth").requireAuth, async (req,res)=>{
  const { run, get } = require("./db");
  const userId = req.user.id;
  const full_name = (req.body.full_name || "").toString();
  const phone = (req.body.phone || "").toString();
  const payment_number = (req.body.payment_number || "").toString();
  await run("UPDATE users SET full_name=?, phone=?, payment_number=? WHERE id=?", [full_name, phone, payment_number, userId]);
  const me = await get("SELECT id, username, email, referral_code, balance_ksh, bonus_ksh, full_name, phone, payment_number FROM users WHERE id=?", [userId]);
  res.json(me);
});

res.json(u);
});

app.patch("/api/me", requireAuth, async (req, res) => {
  const schema = z.object({
    username: z.string().min(3).optional(),
    phone: z.string().optional(),
    email: z.string().email().optional()
  });
  try {
    const data = schema.parse(req.body);

    if (data.username) {
      const taken = await get("SELECT id FROM users WHERE username = ? AND id != ?", [data.username, req.user.id]);
      if (taken) return res.status(400).json({ error: "Username already taken" });
    }
    if (data.email) {
      const taken = await get("SELECT id FROM users WHERE email = ? AND id != ?", [data.email, req.user.id]);
      if (taken) return res.status(400).json({ error: "Email already used" });
    }

    await run(
      "UPDATE users SET username = COALESCE(?, username), phone = COALESCE(?, phone), email = COALESCE(?, email) WHERE id = ?",
      [data.username ?? null, data.phone ?? null, data.email ?? null, req.user.id]
    );
    const updated = await get("SELECT id, username, email, phone, referral_code, balance_ksh FROM users WHERE id = ?", [req.user.id]);
    res.json(updated);
  } catch (e) {
    res.status(400).json({ error: e.message || "Bad request" });
  }
});

app.post("/api/me/password", requireAuth, async (req, res) => {
  const schema = z.object({
    currentPassword: z.string().min(1),
    newPassword: z.string().min(6)
  });
  try {
    const data = schema.parse(req.body);
    const user = await get("SELECT password_hash FROM users WHERE id = ?", [req.user.id]);
    const ok = await bcrypt.compare(data.currentPassword, user.password_hash);
    if (!ok) return res.status(400).json({ error: "Current password is wrong" });
    const newHash = await bcrypt.hash(data.newPassword, 10);
    await run("UPDATE users SET password_hash = ? WHERE id = ?", [newHash, req.user.id]);
    res.json({ ok: true });
  } catch (e) {
    res.status(400).json({ error: e.message || "Bad request" });
  }
});

app.delete("/api/me", requireAuth, async (req, res) => {
  await run("DELETE FROM task_completions WHERE user_id = ?", [req.user.id]);
  await run("DELETE FROM withdrawals WHERE user_id = ?", [req.user.id]);
  await run("DELETE FROM users WHERE id = ?", [req.user.id]);
  res.json({ ok: true });
});

app.get("/api/tasks", requireAuth, async (req, res) => {
  const tasks = await all("SELECT id, title, description, category, reward_ksh, image FROM tasks WHERE active = 1");
  const completed = await all("SELECT task_id FROM task_completions WHERE user_id = ?", [req.user.id]);
  const completedSet = new Set(completed.map(x => x.task_id));
  res.json(tasks.map(t => ({ ...t, completed: completedSet.has(t.id) })));
});

app.get("/api/history", requireAuth, async (req, res) => {
  const rows = await all(`
    SELECT tc.id, tc.created_at, tc.reward_ksh, t.title, t.category
    FROM task_completions tc
    JOIN tasks t ON t.id = tc.task_id
    WHERE tc.user_id = ?
    ORDER BY tc.id DESC
    LIMIT 50
  `, [req.user.id]);
  res.json(rows);
});

app.post("/api/tasks/:id/complete", requireAuth, async (req, res) => {
  const taskId = Number(req.params.id);
  const task = await get("SELECT id, reward_ksh FROM tasks WHERE id = ? AND active = 1", [taskId]);
  if (!task) return res.status(404).json({ error: "Task not found" });

  const already = await get("SELECT id FROM task_completions WHERE user_id = ? AND task_id = ?", [req.user.id, taskId]);
  if (already) return res.status(400).json({ error: "Task already completed" });

  await run("INSERT INTO task_completions (user_id, task_id, reward_ksh) VALUES (?, ?, ?)", [req.user.id, taskId, task.reward_ksh]);
  await run("UPDATE users SET balance_ksh = balance_ksh + ? WHERE id = ?", [task.reward_ksh, req.user.id]);

  const me = await get("SELECT balance_ksh FROM users WHERE id = ?", [req.user.id]);
  res.json({ ok: true, balance_ksh: me.balance_ksh });
});

app.get("/api/withdrawals", requireAuth, async (req, res) => {
  const rows = await all(
    "SELECT id, amount_ksh, phone_number, method, status, created_at FROM withdrawals WHERE user_id = ? ORDER BY id DESC LIMIT 50",
    [req.user.id]
  );
  res.json(rows);
});

app.post("/api/withdrawals", requireAuth, async (req, res) => {
  const schema = z.object({
    amount: z.number().positive(),
    phoneNumber: z.string().min(6),
    method: z.string().min(2)
  });
  try {
    const data = schema.parse(req.body);
    const me = await get("SELECT balance_ksh FROM users WHERE id = ?", [req.user.id]);
    if (me.balance_ksh < data.amount) return res.status(400).json({ error: "Insufficient balance" });

    // demo: instant complete
    await run("UPDATE users SET balance_ksh = balance_ksh - ? WHERE id = ?", [data.amount, req.user.id]);
    await run(
      "INSERT INTO withdrawals (user_id, amount_ksh, phone_number, method, status) VALUES (?, ?, ?, ?, ?)",
      [req.user.id, data.amount, data.phoneNumber, data.method, "Completed"]
    );

    const newMe = await get("SELECT balance_ksh FROM users WHERE id = ?", [req.user.id]);
    res.json({ ok: true, balance_ksh: newMe.balance_ksh });
  } catch (e) {
    res.status(400).json({ error: e.message || "Bad request" });
  }
});

(async () => {

  app.listen(PORT, () => console.log("API on http://localhost:" + PORT));
})();
